# yaml-language-server: $schema=https://json.schemastore.org/github-workflow.json
name: build-windows

on:
  push:
    branches: [ "main" ]
  pull_request:

permissions:
  contents: read
  id-token: write

jobs:
  build:
    runs-on: windows-latest

    env:
      # Set to placeholders so YAML tooling understands these exist.
      # Real values are set at runtime by the "Compute version" step via GITHUB_ENV.
      APP_VERSION: "0.0.0"
      ASSEMBLY_VERSION: "0.0.0.0"
      FILE_VERSION: "0.0.0.0"
      INFORMATIONAL_VERSION: "0.0.0+local"

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Compute version
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'

          $runNumber = [int]'${{ github.run_number }}'
          $sha = '${{ github.sha }}'
          $shortSha = if ($sha.Length -ge 7) { $sha.Substring(0, 7) } else { $sha }

          $refType = '${{ github.ref_type }}'
          $refName = '${{ github.ref_name }}'

          if ($refType -eq 'tag' -and $refName.StartsWith('v')) {
            $tagVersion = $refName.Substring(1)
            if ($tagVersion -notmatch '^\d+\.\d+\.\d+(\.\d+)?$') {
              throw "Tag '$refName' must be v<major>.<minor>.<patch>[.<revision>]"
            }

            $parts = $tagVersion.Split('.')
            if ($parts.Count -eq 3) { $parts = @($parts[0], $parts[1], $parts[2], '0') }

            $appVersion = ($parts[0..2] -join '.')
            $assemblyVersion = ($parts -join '.')
            $fileVersion = $assemblyVersion
            $informational = "$appVersion+tag.$refName"
          } else {
            # Auto-increment per workflow run for non-tag builds
            $appVersion = "1.0.$runNumber"
            $assemblyVersion = "1.0.$runNumber.0"
            $fileVersion = $assemblyVersion
            $informational = "$appVersion+sha.$shortSha"
          }

          "APP_VERSION=$appVersion" | Out-File -FilePath $env:GITHUB_ENV -Append
          "ASSEMBLY_VERSION=$assemblyVersion" | Out-File -FilePath $env:GITHUB_ENV -Append
          "FILE_VERSION=$fileVersion" | Out-File -FilePath $env:GITHUB_ENV -Append
          "INFORMATIONAL_VERSION=$informational" | Out-File -FilePath $env:GITHUB_ENV -Append

          Write-Host "Version: APP_VERSION=$appVersion"
          Write-Host "         ASSEMBLY_VERSION=$assemblyVersion"
          Write-Host "         FILE_VERSION=$fileVersion"
          Write-Host "         INFORMATIONAL_VERSION=$informational"

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: "8.0.x"

      - name: Install Inno Setup (for installer build)
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $iscc = "${env:ProgramFiles(x86)}\Inno Setup 6\ISCC.exe"
          if (-not (Test-Path -LiteralPath $iscc)) {
            choco install innosetup -y --no-progress
          }
          if (-not (Test-Path -LiteralPath $iscc)) { throw "ISCC.exe not found: $iscc" }
          Get-Item -LiteralPath $iscc | Select-Object FullName, Length, LastWriteTime | Format-List

      - name: Setup cosign (Sigstore)
        uses: sigstore/cosign-installer@v3

      - name: Restore
        run: dotnet restore "cm6206_dual_router/Cm6206DualRouter.csproj"

      - name: Build
        run: dotnet build "cm6206_dual_router/Cm6206DualRouter.csproj" -c Release --no-restore

      - name: Publish (self-contained single file)
        shell: pwsh
        run: |
          dotnet publish "cm6206_dual_router/Cm6206DualRouter.csproj" `
            -c Release `
            -r win-x64 `
            --self-contained true `
            /p:PublishSingleFile=true `
            /p:IncludeNativeLibrariesForSelfExtract=true `
            /p:PublishReadyToRun=true `
            /p:DebugType=None `
            /p:DebugSymbols=false `
            /p:Version=$env:APP_VERSION `
            /p:AssemblyVersion=$env:ASSEMBLY_VERSION `
            /p:FileVersion=$env:FILE_VERSION `
            /p:InformationalVersion=$env:INFORMATIONAL_VERSION `
            -o "artifacts/cm6206_dual_router_win-x64"

      - name: Sign published EXE (optional)
        shell: pwsh
        env:
          # NOTE: Some editors/linters warn that `secrets.*` contexts are "invalid".
          # This is expected locally because they cannot see your repo's configured secrets.
          # In GitHub Actions, these resolve correctly when the secrets exist.
          CODESIGN_PFX_BASE64: "${{ secrets.CODESIGN_PFX_BASE64 }}"
          CODESIGN_PFX_PASSWORD: "${{ secrets.CODESIGN_PFX_PASSWORD }}"
          CODESIGN_TIMESTAMP_URL: "${{ secrets.CODESIGN_TIMESTAMP_URL }}"
        run: |
          $ErrorActionPreference = 'Stop'

          if ([string]::IsNullOrWhiteSpace($env:CODESIGN_PFX_BASE64) -or [string]::IsNullOrWhiteSpace($env:CODESIGN_PFX_PASSWORD)) {
            Write-Host 'Code signing skipped (CODESIGN_PFX_BASE64 / CODESIGN_PFX_PASSWORD not set).'
            exit 0
          }

          try {
            $artifactDir = Join-Path $PWD 'artifacts/cm6206_dual_router_win-x64'
            $exe = Join-Path $artifactDir 'Cm6206DualRouter.exe'
            if (-not (Test-Path -LiteralPath $exe)) {
              throw "Expected publish output not found: $exe"
            }

            $pfxPath = Join-Path $env:RUNNER_TEMP 'codesign.pfx'
            [IO.File]::WriteAllBytes($pfxPath, [Convert]::FromBase64String($env:CODESIGN_PFX_BASE64))

            $timestamp = $env:CODESIGN_TIMESTAMP_URL
            if ([string]::IsNullOrWhiteSpace($timestamp)) { $timestamp = 'http://timestamp.digicert.com' }

          function Find-SignTool {
            $cmd = Get-Command signtool.exe -ErrorAction SilentlyContinue
            if ($cmd) { return $cmd.Source }

            $roots = @(
              'C:\Program Files (x86)\Windows Kits\10\bin',
              'C:\Program Files\Windows Kits\10\bin'
            )

            foreach ($root in $roots) {
              if (-not (Test-Path -LiteralPath $root)) { continue }
              $found = Get-ChildItem -LiteralPath $root -Recurse -Filter signtool.exe -ErrorAction SilentlyContinue |
                Sort-Object FullName -Descending |
                Select-Object -First 1
              if ($found) { return $found.FullName }
            }

            return $null
          }

          $signtool = Find-SignTool
          if ([string]::IsNullOrWhiteSpace($signtool)) {
            Write-Host 'Code signing skipped (signtool.exe not found on runner).'
            exit 0
          }

          Write-Host "Using signtool: $signtool"

          & $signtool sign /fd sha256 /a /f $pfxPath /p $env:CODESIGN_PFX_PASSWORD /tr $timestamp /td sha256 $exe
          & $signtool verify /pa /v $exe
          }
          catch {
            Write-Warning "Code signing failed (continuing without signing): $($_.Exception.Message)"
            exit 0
          }

      - name: Generate UI assets (PNG/SVG/9-slice)
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          dotnet run -c Release --project tools/Cm6206AssetGenerator -- --out "artifacts/cm6206_dual_router_win-x64/assets/generated" --theme all

      - name: Build installer (Inno Setup)
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $iscc = "${env:ProgramFiles(x86)}\Inno Setup 6\ISCC.exe"
          if (-not (Test-Path -LiteralPath $iscc)) { throw "ISCC.exe not found: $iscc" }

          New-Item -ItemType Directory -Force -Path "artifacts/installer" | Out-Null
          & $iscc "installer/Cm6206DualRouter.iss" "/DMyAppVersion=$env:APP_VERSION"

          $setupExe = Join-Path $PWD "artifacts/installer/Cm6206DualRouterSetup_$($env:APP_VERSION).exe"
          if (-not (Test-Path -LiteralPath $setupExe)) { throw "Installer output not found: $setupExe" }

      - name: Cosign artifacts (keyless, best-effort)
        if: github.event_name != 'pull_request'
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'

          $outDir = Join-Path $PWD 'artifacts/cosign'
          New-Item -ItemType Directory -Force -Path $outDir | Out-Null

          $exe = Join-Path $PWD 'artifacts/cm6206_dual_router_win-x64/Cm6206DualRouter.exe'
          $setup = Join-Path $PWD ("artifacts/installer/Cm6206DualRouterSetup_{0}.exe" -f $env:APP_VERSION)

          foreach ($f in @($exe, $setup)) {
            if (-not (Test-Path -LiteralPath $f)) { throw "Expected file not found: $f" }
          }

          try {
            cosign sign-blob --yes --output-signature (Join-Path $outDir 'Cm6206DualRouter.exe.sig') --output-certificate (Join-Path $outDir 'Cm6206DualRouter.exe.crt') $exe
            cosign sign-blob --yes --output-signature (Join-Path $outDir ("Cm6206DualRouterSetup_{0}.exe.sig" -f $env:APP_VERSION)) --output-certificate (Join-Path $outDir ("Cm6206DualRouterSetup_{0}.exe.crt" -f $env:APP_VERSION)) $setup
          }
          catch {
            Write-Warning "cosign signing failed (continuing without signatures): $($_.Exception.Message)"
          }

      - name: Create bundle ZIP
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'

          $stage = Join-Path $PWD 'artifacts/bundle_staging'
          if (Test-Path -LiteralPath $stage) { Remove-Item -LiteralPath $stage -Recurse -Force }
          New-Item -ItemType Directory -Force -Path $stage | Out-Null

          $portableSrc = Join-Path $PWD 'artifacts/cm6206_dual_router_win-x64'
          $portableDst = Join-Path $stage 'portable'
          Copy-Item -LiteralPath $portableSrc -Destination $portableDst -Recurse -Force

          $installerDir = Join-Path $stage 'installer'
          New-Item -ItemType Directory -Force -Path $installerDir | Out-Null
          $setupExe = Join-Path $PWD ("artifacts/installer/Cm6206DualRouterSetup_{0}.exe" -f $env:APP_VERSION)
          Copy-Item -LiteralPath $setupExe -Destination $installerDir -Force

          $cosignSrc = Join-Path $PWD 'artifacts/cosign'
          if (Test-Path -LiteralPath $cosignSrc) {
            Copy-Item -LiteralPath $cosignSrc -Destination (Join-Path $stage 'cosign') -Recurse -Force
          }

          Copy-Item -LiteralPath (Join-Path $PWD 'cm6206_dual_router/router.json') -Destination (Join-Path $stage 'router.json') -Force

          @"
          CM6206 Dual Router (bundle)

          - portable\\ : run Cm6206DualRouter.exe (no install)
          - installer\\: optional Inno Setup installer EXE
          - cosign\\   : (if present) Sigstore/cosign signatures (.sig/.crt)
          - router.json : sample config
          "@ | Out-File -FilePath (Join-Path $stage 'README.txt') -Encoding utf8

          $bundle = Join-Path $PWD ("artifacts/cm6206_dual_router_bundle_{0}.zip" -f $env:APP_VERSION)
          if (Test-Path -LiteralPath $bundle) { Remove-Item -LiteralPath $bundle -Force }
          Compress-Archive -Path (Join-Path $stage '*') -DestinationPath $bundle
          Write-Host "Created bundle: $bundle"

      - name: Upload artifact (bundle)
        uses: actions/upload-artifact@v4
        with:
          name: cm6206_dual_router_bundle_${{ env.APP_VERSION }}
          path: artifacts/cm6206_dual_router_bundle_${{ env.APP_VERSION }}.zip

