name: release-windows

on:
  push:
    tags: [ "v*" ]

permissions:
  contents: write
  id-token: write

jobs:
  release:
    runs-on: windows-latest

    env:
      # Set to placeholders so YAML tooling understands these exist.
      # Real values are set at runtime by the "Compute version" step via GITHUB_ENV.
      APP_VERSION: "0.0.0"
      BUNDLE_VERSION: "0.0.0"
      ASSEMBLY_VERSION: "0.0.0.0"
      FILE_VERSION: "0.0.0.0"
      INFORMATIONAL_VERSION: "0.0.0+local"

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: "8.0.x"

      - name: Install Inno Setup (for installer build)
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $iscc = "${env:ProgramFiles(x86)}\Inno Setup 6\ISCC.exe"
          if (-not (Test-Path -LiteralPath $iscc)) {
            choco install innosetup -y --no-progress
          }
          if (-not (Test-Path -LiteralPath $iscc)) { throw "ISCC.exe not found: $iscc" }
          Get-Item -LiteralPath $iscc | Select-Object FullName, Length, LastWriteTime | Format-List

      - name: Setup cosign (Sigstore)
        uses: sigstore/cosign-installer@v3

      - name: Compute version (from tag)
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'

          $refType = '${{ github.ref_type }}'
          $refName = '${{ github.ref_name }}'
          if ($refType -ne 'tag') { throw "Expected tag ref, got: $refType / $refName" }
          if (-not $refName.StartsWith('v')) { throw "Tag must start with 'v' (example: v1.2.3). Got: $refName" }

          # Allow optional suffixes like v0.0.1-hotfix1.
          $bundleVersion = $refName.Substring(1)
          if ($bundleVersion -notmatch '^\d+\.\d+\.\d+(\.\d+)?([\-][0-9A-Za-z\.\-]+)?$') {
            throw "Tag '$refName' must be v<major>.<minor>.<patch>[.<revision>][-suffix]"
          }

          $numeric = ($bundleVersion -split '-', 2)[0]
          $parts = $numeric.Split('.')
          if ($parts.Count -eq 3) { $parts = @($parts[0], $parts[1], $parts[2], '0') }

          $appVersion = ($parts[0..2] -join '.')
          $assemblyVersion = ($parts -join '.')
          $fileVersion = $assemblyVersion
          $informational = "$appVersion+tag.$refName"

          "APP_VERSION=$appVersion" | Out-File -FilePath $env:GITHUB_ENV -Append
          "BUNDLE_VERSION=$bundleVersion" | Out-File -FilePath $env:GITHUB_ENV -Append
          "ASSEMBLY_VERSION=$assemblyVersion" | Out-File -FilePath $env:GITHUB_ENV -Append
          "FILE_VERSION=$fileVersion" | Out-File -FilePath $env:GITHUB_ENV -Append
          "INFORMATIONAL_VERSION=$informational" | Out-File -FilePath $env:GITHUB_ENV -Append

          Write-Host "Release version: $refName -> APP_VERSION=$appVersion (bundle=$bundleVersion)"

      - name: Restore
        run: dotnet restore "cm6206_dual_router/Cm6206DualRouter.csproj"

      - name: Build
        run: dotnet build "cm6206_dual_router/Cm6206DualRouter.csproj" -c Release --no-restore

      - name: Publish (self-contained single file)
        shell: pwsh
        run: |
          dotnet publish "cm6206_dual_router/Cm6206DualRouter.csproj" `
            -c Release `
            -r win-x64 `
            --self-contained true `
            /p:PublishSingleFile=true `
            /p:IncludeNativeLibrariesForSelfExtract=true `
            /p:PublishReadyToRun=true `
            /p:DebugType=None `
            /p:DebugSymbols=false `
            /p:Version=$env:APP_VERSION `
            /p:AssemblyVersion=$env:ASSEMBLY_VERSION `
            /p:FileVersion=$env:FILE_VERSION `
            /p:InformationalVersion=$env:INFORMATIONAL_VERSION `
            -o "artifacts/cm6206_dual_router_win-x64"

      - name: Sign published EXE (optional)
        shell: pwsh
        env:
          # NOTE: Some editors/linters warn that `secrets.*` contexts are "invalid".
          # This is expected locally because they cannot see your repo's configured secrets.
          # In GitHub Actions, these resolve correctly when the secrets exist.
          CODESIGN_PFX_BASE64: ${{ secrets.CODESIGN_PFX_BASE64 }}
          CODESIGN_PFX_PASSWORD: ${{ secrets.CODESIGN_PFX_PASSWORD }}
          CODESIGN_TIMESTAMP_URL: ${{ secrets.CODESIGN_TIMESTAMP_URL }}
        run: |
          $ErrorActionPreference = 'Stop'

          if ([string]::IsNullOrWhiteSpace($env:CODESIGN_PFX_BASE64) -or [string]::IsNullOrWhiteSpace($env:CODESIGN_PFX_PASSWORD)) {
            Write-Host 'Code signing skipped (CODESIGN_PFX_BASE64 / CODESIGN_PFX_PASSWORD not set).'
            exit 0
          }

          try {
            $artifactDir = Join-Path $PWD 'artifacts/cm6206_dual_router_win-x64'
            $exe = Join-Path $artifactDir 'Cm6206DualRouter.exe'
            if (-not (Test-Path -LiteralPath $exe)) {
              throw "Expected publish output not found: $exe"
            }

            $pfxPath = Join-Path $env:RUNNER_TEMP 'codesign.pfx'
            [IO.File]::WriteAllBytes($pfxPath, [Convert]::FromBase64String($env:CODESIGN_PFX_BASE64))

            $timestamp = $env:CODESIGN_TIMESTAMP_URL
            if ([string]::IsNullOrWhiteSpace($timestamp)) { $timestamp = 'http://timestamp.digicert.com' }

          function Find-SignTool {
            $cmd = Get-Command signtool.exe -ErrorAction SilentlyContinue
            if ($cmd) { return $cmd.Source }

            $roots = @(
              'C:\Program Files (x86)\Windows Kits\10\bin',
              'C:\Program Files\Windows Kits\10\bin'
            )

            foreach ($root in $roots) {
              if (-not (Test-Path -LiteralPath $root)) { continue }
              $found = Get-ChildItem -LiteralPath $root -Recurse -Filter signtool.exe -ErrorAction SilentlyContinue |
                Sort-Object FullName -Descending |
                Select-Object -First 1
              if ($found) { return $found.FullName }
            }

            return $null
          }

          $signtool = Find-SignTool
          if ([string]::IsNullOrWhiteSpace($signtool)) {
            Write-Host 'Code signing skipped (signtool.exe not found on runner).'
            exit 0
          }

          Write-Host "Using signtool: $signtool"

          & $signtool sign /fd sha256 /a /f $pfxPath /p $env:CODESIGN_PFX_PASSWORD /tr $timestamp /td sha256 $exe
          & $signtool verify /pa /v $exe
          }
          catch {
            Write-Warning "Code signing failed (continuing without signing): $($_.Exception.Message)"
            exit 0
          }

      - name: Generate UI assets (PNG/SVG/9-slice)
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          dotnet run -c Release --project tools/Cm6206AssetGenerator -- --out "artifacts/cm6206_dual_router_win-x64/assets/generated" --theme all

      - name: Build installer (Inno Setup)
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $iscc = "${env:ProgramFiles(x86)}\Inno Setup 6\ISCC.exe"
          if (-not (Test-Path -LiteralPath $iscc)) { throw "ISCC.exe not found: $iscc" }

          New-Item -ItemType Directory -Force -Path "artifacts/installer" | Out-Null

          & $iscc "installer/Cm6206DualRouter.iss" "/DMyAppVersion=$env:BUNDLE_VERSION"

          $setupExe = Join-Path $PWD "artifacts/installer/Cm6206DualRouterSetup_$($env:BUNDLE_VERSION).exe"
          if (-not (Test-Path -LiteralPath $setupExe)) { throw "Installer output not found: $setupExe" }

      - name: Cosign release assets (keyless)
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'

          $outDir = Join-Path $PWD 'artifacts/cosign'
          New-Item -ItemType Directory -Force -Path $outDir | Out-Null

          $exe = Join-Path $PWD 'artifacts/cm6206_dual_router_win-x64/Cm6206DualRouter.exe'
          $setup = Join-Path $PWD ("artifacts/installer/Cm6206DualRouterSetup_{0}.exe" -f $env:BUNDLE_VERSION)

          foreach ($f in @($exe, $setup)) {
            if (-not (Test-Path -LiteralPath $f)) { throw "Expected file not found: $f" }
          }

          # Keyless signing uses GitHub OIDC; requires workflow permission: id-token: write
          cosign sign-blob --yes --output-signature (Join-Path $outDir 'Cm6206DualRouter.exe.sig') --output-certificate (Join-Path $outDir 'Cm6206DualRouter.exe.crt') $exe
          cosign sign-blob --yes --output-signature (Join-Path $outDir ("Cm6206DualRouterSetup_{0}.exe.sig" -f $env:BUNDLE_VERSION)) --output-certificate (Join-Path $outDir ("Cm6206DualRouterSetup_{0}.exe.crt" -f $env:BUNDLE_VERSION)) $setup

      - name: Create bundle ZIP
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'

          $stage = Join-Path $PWD 'artifacts/bundle_staging'
          if (Test-Path -LiteralPath $stage) { Remove-Item -LiteralPath $stage -Recurse -Force }
          New-Item -ItemType Directory -Force -Path $stage | Out-Null

          $portableSrc = Join-Path $PWD 'artifacts/cm6206_dual_router_win-x64'
          $portableDst = Join-Path $stage 'portable'
          Copy-Item -LiteralPath $portableSrc -Destination $portableDst -Recurse -Force

          $installerDir = Join-Path $stage 'installer'
          New-Item -ItemType Directory -Force -Path $installerDir | Out-Null
          $setupExe = Join-Path $PWD ("artifacts/installer/Cm6206DualRouterSetup_{0}.exe" -f $env:BUNDLE_VERSION)
          Copy-Item -LiteralPath $setupExe -Destination $installerDir -Force

          $cosignSrc = Join-Path $PWD 'artifacts/cosign'
          if (Test-Path -LiteralPath $cosignSrc) {
            Copy-Item -LiteralPath $cosignSrc -Destination (Join-Path $stage 'cosign') -Recurse -Force
          }

          Copy-Item -LiteralPath (Join-Path $PWD 'cm6206_dual_router/router.json') -Destination (Join-Path $stage 'router.json') -Force

          @"
          CM6206 Dual Router (bundle)

          - portable\\ : run Cm6206DualRouter.exe (no install)
          - installer\\: optional Inno Setup installer EXE
          - cosign\\   : Sigstore/cosign signatures (.sig/.crt)
          - router.json : sample config
          "@ | Out-File -FilePath (Join-Path $stage 'README.txt') -Encoding utf8

          $bundle = Join-Path $PWD ("artifacts/cm6206_dual_router_bundle_{0}.zip" -f $env:BUNDLE_VERSION)
          if (Test-Path -LiteralPath $bundle) { Remove-Item -LiteralPath $bundle -Force }
          Compress-Archive -Path (Join-Path $stage '*') -DestinationPath $bundle
          Write-Host "Created bundle: $bundle"

      - name: Upload artifact (bundle)
        uses: actions/upload-artifact@v4
        with:
          name: cm6206_dual_router_bundle_${{ env.BUNDLE_VERSION }}
          path: artifacts/cm6206_dual_router_bundle_${{ env.BUNDLE_VERSION }}.zip

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          files: |
            artifacts/cm6206_dual_router_bundle_${{ env.BUNDLE_VERSION }}.zip
          generate_release_notes: true
